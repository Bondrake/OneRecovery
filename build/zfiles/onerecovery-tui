#!/bin/ash
#
# OneRecovery TUI (Text User Interface)
# A simple menu-driven interface for common recovery tasks
#

# ANSI colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
WHITE='\033[1;37m'
GRAY='\033[1;30m'
RESET='\033[0m'

# Terminal size
TERM_WIDTH=$(tput cols)
TERM_HEIGHT=$(tput lines)

# Version
VERSION="1.1.0"

# Log file
LOG_FILE="/tmp/onerecovery.log"
touch "$LOG_FILE"

# Function to center text
center_text() {
    local text="$1"
    local width="${2:-$TERM_WIDTH}"
    local padding=$(( (width - ${#text}) / 2 ))
    printf "%${padding}s" ""
    printf "%s" "$text"
    printf "%${padding}s" ""
    echo
}

# Function to draw a line
draw_line() {
    local width="${1:-$TERM_WIDTH}"
    local char="${2:-â•}"
    printf "%${width}s" "" | tr " " "$char"
    echo
}

# Function to show header
show_header() {
    clear
    echo -e "${BLUE}"
    echo "      ____________  "
    echo "    /|------------| "
    echo "   /_|  .---.     | "
    echo "  |    /     \    | "
    echo "  |    \.6-6./    | "
    echo "  |    /\`\_/\`\    | "
    echo "  |   //  _  \\\   | "
    echo "  |  | \     / |  | "
    echo "  | /\`\_\`>  <_/\`\ | "
    echo "  | \__/'---'\__/ | "
    echo "  |_______________| "
    echo "                    "
    echo -e "${GREEN}   OneRecovery v$VERSION   ${RESET}"
    draw_line
}

# Function to show footer
show_footer() {
    draw_line
    echo -e "${YELLOW}Press 'q' to quit or 'h' for help${RESET}"
}

# Function to show a message with pause
show_message() {
    local message="$1"
    local type="${2:-info}"
    
    case "$type" in
        info)    echo -e "${BLUE}[INFO]${RESET} $message" ;;
        success) echo -e "${GREEN}[SUCCESS]${RESET} $message" ;;
        warning) echo -e "${YELLOW}[WARNING]${RESET} $message" ;;
        error)   echo -e "${RED}[ERROR]${RESET} $message" ;;
    esac
    
    echo "Press any key to continue..."
    read -n 1
}

# Function to log messages
log_message() {
    local message="$1"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo "[$timestamp] $message" >> "$LOG_FILE"
}

# Function to detect system information
detect_system_info() {
    log_message "Detecting system information"
    
    # Basic system information
    HOSTNAME=$(hostname)
    KERNEL=$(uname -r)
    CPU_MODEL=$(grep "model name" /proc/cpuinfo | head -1 | cut -d ':' -f 2 | sed 's/^[ \t]*//')
    CPU_CORES=$(grep -c processor /proc/cpuinfo)
    MEM_TOTAL=$(free -h | grep Mem | awk '{print $2}')
    
    # Storage information
    DISKS=$(lsblk -d -o NAME,SIZE,MODEL | grep -v loop | grep -v NAME)
    
    # Network information
    INTERFACES=$(ip -o link show | grep -v "lo" | awk -F': ' '{print $2}')
    
    log_message "System information detection complete"
}

# Function to show system information
show_system_info() {
    show_header
    echo -e "${WHITE}System Information${RESET}"
    echo
    echo -e "${CYAN}Hostname:${RESET}    $HOSTNAME"
    echo -e "${CYAN}Kernel:${RESET}      $KERNEL"
    echo -e "${CYAN}CPU:${RESET}         $CPU_MODEL ($CPU_CORES cores)"
    echo -e "${CYAN}Memory:${RESET}      $MEM_TOTAL"
    echo
    
    echo -e "${WHITE}Disk Information${RESET}"
    echo -e "${CYAN}Available disks:${RESET}"
    echo "$DISKS"
    echo
    
    echo -e "${WHITE}Network Information${RESET}"
    echo -e "${CYAN}Available interfaces:${RESET}"
    for iface in $INTERFACES; do
        local ip_addr=$(ip -o -4 addr show dev "$iface" | awk '{print $4}')
        local status=$(cat /sys/class/net/$iface/operstate)
        echo "  $iface: $ip_addr ($status)"
    done
    
    show_footer
    read -n 1 key
}

# Function to scan disks
scan_disks() {
    show_header
    echo -e "${WHITE}Scanning Disks...${RESET}"
    echo
    
    log_message "Scanning disks"
    
    # List block devices
    echo -e "${CYAN}Block Devices:${RESET}"
    lsblk -o NAME,SIZE,TYPE,MOUNTPOINT,FSTYPE
    echo
    
    # Partitioning schemes
    echo -e "${CYAN}Partition Tables:${RESET}"
    for disk in $(lsblk -d -n -o NAME | grep -v loop); do
        echo -n "  /dev/$disk: "
        fdisk -l /dev/$disk | grep -m 1 "Disklabel type" | cut -d ":" -f 2 || echo "Unknown"
    done
    echo
    
    # File systems
    echo -e "${CYAN}File Systems:${RESET}"
    df -Th | grep -v tmpfs | grep -v devtmpfs
    
    log_message "Disk scan complete"
    
    show_footer
    read -n 1 key
}

# Function to mount a filesystem
mount_filesystem() {
    show_header
    echo -e "${WHITE}Mount Filesystem${RESET}"
    echo
    
    # Show available partitions
    echo -e "${CYAN}Available Partitions:${RESET}"
    lsblk -o NAME,SIZE,TYPE,FSTYPE | grep -v loop | grep part
    echo
    
    # Get user input
    echo -n "Enter partition to mount (e.g., sda1): "
    read partition
    
    if [ -z "$partition" ]; then
        show_message "No partition specified" "error"
        return
    fi
    
    # Verify partition exists
    if [ ! -b "/dev/$partition" ]; then
        show_message "Partition /dev/$partition does not exist" "error"
        return
    fi
    
    # Create mount point
    mount_point="/mnt/$partition"
    mkdir -p "$mount_point"
    
    # Determine filesystem type
    fs_type=$(lsblk -n -o FSTYPE /dev/$partition)
    
    log_message "Mounting /dev/$partition ($fs_type) to $mount_point"
    
    # Mount the filesystem
    mount_options=""
    
    case "$fs_type" in
        ext4|ext3|ext2)
            mount_options="-o rw"
            ;;
        ntfs)
            # Check if ntfs-3g is available
            if command -v ntfs-3g > /dev/null; then
                mount_options="-t ntfs-3g -o rw"
            else
                mount_options="-t ntfs -o rw"
            fi
            ;;
        vfat|msdos)
            mount_options="-t vfat -o rw,umask=000"
            ;;
        exfat)
            mount_options="-t exfat -o rw"
            ;;
        xfs)
            mount_options="-t xfs -o rw"
            ;;
        zfs)
            # Special handling for ZFS
            if command -v zpool > /dev/null && command -v zfs > /dev/null; then
                pool_name=$(echo "$partition" | sed 's/[0-9]//g')
                show_message "ZFS detected. Please use the ZFS menu option for ZFS filesystems" "info"
                return
            else
                show_message "ZFS tools not available" "error"
                return
            fi
            ;;
        *)
            if [ -z "$fs_type" ]; then
                show_message "No filesystem detected on /dev/$partition" "error"
                return
            else
                mount_options="-t $fs_type"
            fi
            ;;
    esac
    
    # Try to mount
    if eval "mount $mount_options /dev/$partition $mount_point"; then
        show_message "Successfully mounted /dev/$partition to $mount_point" "success"
        log_message "Successfully mounted /dev/$partition to $mount_point"
    else
        show_message "Failed to mount /dev/$partition" "error"
        log_message "Failed to mount /dev/$partition"
    fi
}

# Function to unmount a filesystem
unmount_filesystem() {
    show_header
    echo -e "${WHITE}Unmount Filesystem${RESET}"
    echo
    
    # Show mounted filesystems
    echo -e "${CYAN}Mounted Partitions:${RESET}"
    mount | grep -v tmpfs | grep -v proc | grep -v sysfs | grep -v devpts
    echo
    
    # Get user input
    echo -n "Enter mount point to unmount (e.g., /mnt/sda1): "
    read mount_point
    
    if [ -z "$mount_point" ]; then
        show_message "No mount point specified" "error"
        return
    fi
    
    # Check if mount point is actually mounted
    if ! mount | grep -q " $mount_point "; then
        show_message "$mount_point is not mounted" "error"
        return
    fi
    
    log_message "Unmounting $mount_point"
    
    # Try to unmount
    if umount "$mount_point"; then
        show_message "Successfully unmounted $mount_point" "success"
        log_message "Successfully unmounted $mount_point"
    else
        show_message "Failed to unmount $mount_point" "error"
        log_message "Failed to unmount $mount_point"
    fi
}

# Function to handle ZFS operations
zfs_operations() {
    # Check if ZFS is available
    if ! command -v zpool > /dev/null || ! command -v zfs > /dev/null; then
        show_message "ZFS tools are not available" "error"
        return
    fi
    
    show_header
    echo -e "${WHITE}ZFS Operations${RESET}"
    echo
    
    # Show ZFS submenu
    echo "1. Import all pools"
    echo "2. List pools"
    echo "3. List datasets"
    echo "4. Export all pools"
    echo "5. Back to main menu"
    echo
    
    echo -n "Select an option: "
    read -n 1 zfs_option
    echo
    
    case "$zfs_option" in
        1)
            log_message "Importing all ZFS pools"
            zpool import -a
            show_message "Attempted to import all ZFS pools" "info"
            ;;
        2)
            log_message "Listing ZFS pools"
            zpool_list=$(zpool list)
            show_header
            echo -e "${WHITE}ZFS Pools${RESET}"
            echo
            echo "$zpool_list"
            echo
            show_footer
            read -n 1 key
            ;;
        3)
            log_message "Listing ZFS datasets"
            zfs_list=$(zfs list)
            show_header
            echo -e "${WHITE}ZFS Datasets${RESET}"
            echo
            echo "$zfs_list"
            echo
            show_footer
            read -n 1 key
            ;;
        4)
            log_message "Exporting all ZFS pools"
            zpool export -a
            show_message "Attempted to export all ZFS pools" "info"
            ;;
        *)
            # Back to main menu or invalid option
            ;;
    esac
}

# Function to handle network operations
network_operations() {
    show_header
    echo -e "${WHITE}Network Operations${RESET}"
    echo
    
    # Show network submenu
    echo "1. Configure network interface"
    echo "2. Test connectivity"
    echo "3. Show network status"
    echo "4. Back to main menu"
    echo
    
    echo -n "Select an option: "
    read -n 1 net_option
    echo
    
    case "$net_option" in
        1)
            show_header
            echo -e "${WHITE}Configure Network Interface${RESET}"
            echo
            
            # Show available interfaces
            echo -e "${CYAN}Available interfaces:${RESET}"
            ip -o link show | grep -v "lo" | awk -F': ' '{print $2}'
            echo
            
            # Get user input
            echo -n "Enter interface name (e.g., eth0): "
            read iface
            
            if [ -z "$iface" ]; then
                show_message "No interface specified" "error"
                return
            fi
            
            # Check if interface exists
            if ! ip link show "$iface" &> /dev/null; then
                show_message "Interface $iface does not exist" "error"
                return
            fi
            
            # Configuration method
            echo -n "Use DHCP? (y/n): "
            read -n 1 use_dhcp
            echo
            
            log_message "Configuring network interface $iface"
            
            if [ "$use_dhcp" = "y" ] || [ "$use_dhcp" = "Y" ]; then
                # Configure with DHCP
                ip link set "$iface" up
                udhcpc -i "$iface"
                show_message "DHCP configuration attempted on $iface" "info"
            else
                # Manual configuration
                echo -n "Enter IP address (e.g., 192.168.1.100/24): "
                read ip_addr
                
                if [ -z "$ip_addr" ]; then
                    show_message "No IP address specified" "error"
                    return
                fi
                
                echo -n "Enter gateway (e.g., 192.168.1.1): "
                read gateway
                
                # Configure manually
                ip link set "$iface" up
                ip addr add "$ip_addr" dev "$iface"
                
                if [ -n "$gateway" ]; then
                    ip route add default via "$gateway"
                fi
                
                # Configure DNS
                echo "nameserver 8.8.8.8" > /etc/resolv.conf
                echo "nameserver 1.1.1.1" >> /etc/resolv.conf
                
                show_message "Manual configuration applied to $iface" "info"
            fi
            ;;
        2)
            show_header
            echo -e "${WHITE}Test Connectivity${RESET}"
            echo
            
            echo -n "Enter hostname or IP to ping (e.g., google.com): "
            read target
            
            if [ -z "$target" ]; then
                target="8.8.8.8"
                echo "No target specified, using default (8.8.8.8)"
            fi
            
            log_message "Testing connectivity to $target"
            
            echo "Pinging $target (press Ctrl+C to stop)..."
            ping -c 4 "$target"
            
            echo
            show_footer
            read -n 1 key
            ;;
        3)
            show_header
            echo -e "${WHITE}Network Status${RESET}"
            echo
            
            log_message "Showing network status"
            
            echo -e "${CYAN}Interfaces:${RESET}"
            ip addr
            echo
            
            echo -e "${CYAN}Routing:${RESET}"
            ip route
            echo
            
            echo -e "${CYAN}DNS Configuration:${RESET}"
            cat /etc/resolv.conf
            echo
            
            show_footer
            read -n 1 key
            ;;
        *)
            # Back to main menu or invalid option
            ;;
    esac
}

# Function to handle data recovery operations
data_recovery() {
    show_header
    echo -e "${WHITE}Data Recovery Operations${RESET}"
    echo
    
    # Show data recovery submenu
    echo "1. Run TestDisk/PhotoRec for recovery"
    echo "2. Copy files between partitions"
    echo "3. Create disk image"
    echo "4. Back to main menu"
    echo
    
    echo -n "Select an option: "
    read -n 1 recovery_option
    echo
    
    case "$recovery_option" in
        1)
            # Check if recovery tools are available
            if command -v testdisk > /dev/null; then
                log_message "Starting TestDisk for file recovery"
                show_message "Starting TestDisk/PhotoRec file recovery tool. Please follow the on-screen instructions." "info"
                testdisk
            else
                show_message "TestDisk is not available in this build" "error"
            fi
            ;;
        2)
            show_header
            echo -e "${WHITE}Copy Files Between Partitions${RESET}"
            echo
            
            # Show mounted filesystems
            echo -e "${CYAN}Mounted Partitions:${RESET}"
            mount | grep -v tmpfs | grep -v proc | grep -v sysfs | grep -v devpts
            echo
            
            # Get source
            echo -n "Enter source path: "
            read source_path
            
            if [ -z "$source_path" ] || [ ! -e "$source_path" ]; then
                show_message "Invalid source path" "error"
                return
            fi
            
            # Get destination
            echo -n "Enter destination path: "
            read dest_path
            
            if [ -z "$dest_path" ]; then
                show_message "Invalid destination path" "error"
                return
            fi
            
            # Create destination directory if it doesn't exist
            mkdir -p "$(dirname "$dest_path")"
            
            log_message "Copying from $source_path to $dest_path"
            
            # Copy files
            if cp -rv "$source_path" "$dest_path"; then
                show_message "Files copied successfully" "success"
            else
                show_message "Failed to copy files" "error"
            fi
            ;;
        3)
            show_header
            echo -e "${WHITE}Create Disk Image${RESET}"
            echo
            
            # Show available disks
            echo -e "${CYAN}Available Disks/Partitions:${RESET}"
            lsblk -o NAME,SIZE,TYPE | grep -v loop
            echo
            
            # Get source disk/partition
            echo -n "Enter source disk/partition (e.g., sda1): "
            read source_disk
            
            if [ -z "$source_disk" ] || [ ! -b "/dev/$source_disk" ]; then
                show_message "Invalid disk/partition" "error"
                return
            fi
            
            # Get destination
            echo -n "Enter destination path for image file: "
            read dest_image
            
            if [ -z "$dest_image" ]; then
                show_message "Invalid destination path" "error"
                return
            fi
            
            # Create destination directory if it doesn't exist
            mkdir -p "$(dirname "$dest_image")"
            
            log_message "Creating disk image of /dev/$source_disk to $dest_image"
            
            # Check if destination has enough space
            source_size=$(blockdev --getsize64 "/dev/$source_disk")
            dest_dir=$(dirname "$dest_image")
            dest_free=$(df -B1 "$dest_dir" | awk 'NR==2 {print $4}')
            
            if [ "$dest_free" -lt "$source_size" ]; then
                show_message "Not enough free space in destination" "error"
                return
            fi
            
            # Create the image
            show_message "Creating disk image. This may take a while..." "info"
            
            if dd if="/dev/$source_disk" of="$dest_image" bs=4M status=progress; then
                show_message "Disk image created successfully" "success"
            else
                show_message "Failed to create disk image" "error"
            fi
            ;;
        *)
            # Back to main menu or invalid option
            ;;
    esac
}

# Function to show system logs
show_logs() {
    show_header
    echo -e "${WHITE}System Logs${RESET}"
    echo
    
    # Show logs submenu
    echo "1. System log (dmesg)"
    echo "2. OneRecovery operations log"
    echo "3. Back to main menu"
    echo
    
    echo -n "Select an option: "
    read -n 1 log_option
    echo
    
    case "$log_option" in
        1)
            show_header
            echo -e "${WHITE}System Log (dmesg)${RESET}"
            echo
            dmesg | less
            ;;
        2)
            show_header
            echo -e "${WHITE}OneRecovery Operations Log${RESET}"
            echo
            cat "$LOG_FILE" | less
            ;;
        *)
            # Back to main menu or invalid option
            ;;
    esac
}

# Function to show help
show_help() {
    show_header
    echo -e "${WHITE}OneRecovery Help${RESET}"
    echo
    echo "OneRecovery is a lightweight Linux system for system recovery and maintenance."
    echo
    echo -e "${CYAN}Main Menu Options:${RESET}"
    echo "1. System Information - Display hardware and system details"
    echo "2. Disk Operations - Scan, mount, format, and manage storage devices"
    echo "3. Network Operations - Configure and test network connectivity"
    echo "4. Data Recovery - Tools for recovering lost data"
    echo "5. ZFS Operations - Manage ZFS pools and datasets"
    echo "6. Advanced System Tools - Hardware diagnostics, security, and boot repair"
    echo "7. View Logs - Access system and recovery logs"
    echo "8. Shell - Access the command line interface"
    echo "9. Help - Display this help information"
    echo "0. Reboot/Shutdown - Power options"
    echo
    echo -e "${CYAN}Navigation:${RESET}"
    echo "- Use the number keys to select menu options"
    echo "- Press 'q' at any time to return to the main menu"
    echo "- Press 'h' for help from any menu"
    echo
    echo -e "${CYAN}Common Tasks:${RESET}"
    echo "- Mount a filesystem: Use option 2 > Mount Filesystem"
    echo "- Format a partition: Use option 2 > Format Partition"
    echo "- Check filesystem: Use option 2 > Check Filesystem"
    echo "- Copy files: Use option 4 > Copy Files Between Partitions"
    echo "- Recover deleted files: Use option 4 > TestDisk/PhotoRec"
    echo "- Configure network: Use option 3 > Configure Network Interface"
    echo "- View hardware details: Use option 6 > Hardware Information Tools"
    echo "- Repair boot issues: Use option 6 > Boot Repair"
    echo "- Check disk health: Use option 6 > Hardware Information > Disk SMART Status"
    echo "- Generate passwords: Use option 6 > Security Tools > Generate Random Password"
    echo
    show_footer
    read -n 1 key
}

# Function to format a partition
format_partition() {
    show_header
    echo -e "${WHITE}Format Partition${RESET}"
    echo -e "${RED}WARNING: Formatting will erase ALL data on the selected partition!${RESET}"
    echo
    
    # Show available partitions
    echo -e "${CYAN}Available Partitions:${RESET}"
    lsblk -o NAME,SIZE,TYPE,FSTYPE | grep -v loop | grep part
    echo
    
    # Get user input
    echo -n "Enter partition to format (e.g., sda1): "
    read partition
    
    if [ -z "$partition" ]; then
        show_message "No partition specified" "error"
        return
    fi
    
    # Verify partition exists
    if [ ! -b "/dev/$partition" ]; then
        show_message "Partition /dev/$partition does not exist" "error"
        return
    fi
    
    # Check if partition is mounted
    if mount | grep -q "/dev/$partition"; then
        show_message "Partition /dev/$partition is mounted. Please unmount it first." "error"
        return
    fi
    
    # Choose filesystem type
    echo
    echo -e "${CYAN}Available Filesystem Types:${RESET}"
    echo "1. ext4 (Linux standard filesystem)"
    echo "2. ext3 (Older Linux filesystem)"
    echo "3. vfat (Compatible with Windows/FAT32)"
    echo "4. exfat (Enhanced FAT, compatible with most systems)"
    echo "5. xfs (High-performance Linux filesystem)"
    echo "6. btrfs (Modern Linux filesystem with advanced features)"
    echo "7. ntfs (Windows filesystem)"
    echo
    
    echo -n "Select filesystem type [1-7]: "
    read -n 1 fs_type_option
    echo
    
    # Map option to filesystem type and command
    case "$fs_type_option" in
        1)
            fs_type="ext4"
            format_cmd="mkfs.ext4 -F"
            ;;
        2)
            fs_type="ext3"
            format_cmd="mkfs.ext3 -F"
            ;;
        3)
            fs_type="vfat"
            format_cmd="mkfs.vfat -F 32"
            ;;
        4)
            fs_type="exfat"
            # Check if exfat tools are available
            if command -v mkfs.exfat > /dev/null; then
                format_cmd="mkfs.exfat"
            else
                show_message "exfat tools not available in this build" "error"
                return
            fi
            ;;
        5)
            fs_type="xfs"
            # Check if xfs tools are available
            if command -v mkfs.xfs > /dev/null; then
                format_cmd="mkfs.xfs -f"
            else
                show_message "xfs tools not available in this build" "error"
                return
            fi
            ;;
        6)
            fs_type="btrfs"
            # Check if btrfs tools are available
            if command -v mkfs.btrfs > /dev/null; then
                format_cmd="mkfs.btrfs -f"
            else
                show_message "btrfs tools not available in this build" "error"
                return
            fi
            ;;
        7)
            fs_type="ntfs"
            # Check if ntfs tools are available
            if command -v mkfs.ntfs > /dev/null; then
                format_cmd="mkfs.ntfs -f"
            else
                show_message "ntfs tools not available in this build" "error"
                return
            fi
            ;;
        *)
            show_message "Invalid filesystem type selected" "error"
            return
            ;;
    esac
    
    # Confirmation
    echo
    echo -e "${RED}WARNING: You are about to format /dev/$partition as $fs_type.${RESET}"
    echo -e "${RED}ALL DATA ON THIS PARTITION WILL BE ERASED!${RESET}"
    echo
    echo -n "Are you sure you want to continue? (y/n): "
    read -n 1 confirm
    echo
    
    if [ "$confirm" != "y" ] && [ "$confirm" != "Y" ]; then
        show_message "Format operation cancelled" "info"
        return
    fi
    
    # Show progress spinner
    log_message "Formatting /dev/$partition as $fs_type"
    echo "Formatting /dev/$partition as $fs_type..."
    
    # Create a background process for formatting
    ($format_cmd /dev/$partition) &
    format_pid=$!
    
    # Display spinner while formatting is in progress
    chars="/-\\|"
    while kill -0 $format_pid 2>/dev/null; do
        for (( i=0; i<${#chars}; i++ )); do
            echo -en "\r${CYAN}Formatting... ${chars:$i:1}${RESET}"
            sleep 0.2
        done
    done
    
    # Check if formatting was successful
    wait $format_pid
    format_status=$?
    
    if [ $format_status -eq 0 ]; then
        echo -en "\r${GREEN}Formatting complete!     ${RESET}\n"
        show_message "Partition /dev/$partition has been formatted as $fs_type" "success"
        log_message "Successfully formatted /dev/$partition as $fs_type"
    else
        echo -en "\r${RED}Formatting failed!       ${RESET}\n"
        show_message "Failed to format /dev/$partition" "error"
        log_message "Failed to format /dev/$partition as $fs_type"
    fi
}

# Function to check a filesystem
check_filesystem() {
    show_header
    echo -e "${WHITE}Check Filesystem${RESET}"
    echo
    
    # Show available partitions
    echo -e "${CYAN}Available Partitions:${RESET}"
    lsblk -o NAME,SIZE,TYPE,FSTYPE | grep -v loop | grep part
    echo
    
    # Get user input
    echo -n "Enter partition to check (e.g., sda1): "
    read partition
    
    if [ -z "$partition" ]; then
        show_message "No partition specified" "error"
        return
    fi
    
    # Verify partition exists
    if [ ! -b "/dev/$partition" ]; then
        show_message "Partition /dev/$partition does not exist" "error"
        return
    fi
    
    # Get filesystem type
    fs_type=$(lsblk -n -o FSTYPE /dev/$partition)
    
    if [ -z "$fs_type" ]; then
        show_message "Unable to determine filesystem type for /dev/$partition" "error"
        return
    fi
    
    # Check if filesystem is mounted
    if mount | grep -q "/dev/$partition"; then
        echo -e "${YELLOW}Warning: Filesystem is mounted. It's recommended to check unmounted filesystems.${RESET}"
        echo -n "Do you want to continue anyway? (y/n): "
        read -n 1 continue_mounted
        echo
        
        if [ "$continue_mounted" != "y" ] && [ "$continue_mounted" != "Y" ]; then
            show_message "Filesystem check cancelled" "info"
            return
        fi
    fi
    
    # Choose mode
    echo
    echo -e "${CYAN}Check Mode:${RESET}"
    echo "1. Read-only check (safe, no repairs)"
    echo "2. Repair automatically (non-interactive)"
    echo "3. Repair interactively (manual confirmation)"
    echo
    
    echo -n "Select check mode [1-3]: "
    read -n 1 check_mode
    echo
    
    # Determine check command based on filesystem type and mode
    case "$fs_type" in
        ext4|ext3|ext2)
            case "$check_mode" in
                1) check_cmd="e2fsck -n" ;;
                2) check_cmd="e2fsck -p" ;;
                3) check_cmd="e2fsck" ;;
                *) 
                    show_message "Invalid check mode selected" "error"
                    return
                    ;;
            esac
            ;;
        xfs)
            # XFS check is always read-only unless mounted
            check_cmd="xfs_repair -n"
            if [ "$check_mode" != "1" ]; then
                echo -e "${YELLOW}Note: xfs_repair can only perform repairs when the filesystem is unmounted.${RESET}"
                if ! mount | grep -q "/dev/$partition"; then
                    # Only allow repair if unmounted
                    check_cmd="xfs_repair"
                fi
            fi
            ;;
        vfat|msdos|exfat)
            case "$check_mode" in
                1) check_cmd="fsck.vfat -n" ;;
                2) check_cmd="fsck.vfat -a" ;;
                3) check_cmd="fsck.vfat -r" ;;
                *) 
                    show_message "Invalid check mode selected" "error"
                    return
                    ;;
            esac
            ;;
        ntfs)
            # Check if ntfsfix is available
            if ! command -v ntfsfix > /dev/null; then
                show_message "ntfsfix not available in this build" "error"
                return
            fi
            check_cmd="ntfsfix"
            ;;
        btrfs)
            # btrfs check is always read-only
            check_cmd="btrfs check"
            ;;
        *)
            show_message "Filesystem check not supported for $fs_type" "error"
            return
            ;;
    esac
    
    # Run filesystem check
    log_message "Checking filesystem on /dev/$partition ($fs_type)"
    echo "Checking filesystem on /dev/$partition ($fs_type)..."
    echo
    
    # Run the check command and capture output
    check_output=$($check_cmd /dev/$partition 2>&1)
    check_status=$?
    
    # Display results
    show_header
    echo -e "${WHITE}Filesystem Check Results${RESET}"
    echo
    
    if [ $check_status -eq 0 ]; then
        echo -e "${GREEN}Filesystem check completed successfully.${RESET}"
        log_message "Filesystem check completed successfully on /dev/$partition"
    else
        echo -e "${YELLOW}Filesystem check found issues (exit code: $check_status).${RESET}"
        log_message "Filesystem check found issues on /dev/$partition (exit code: $check_status)"
    fi
    
    echo
    echo -e "${CYAN}Check Output:${RESET}"
    echo "$check_output"
    echo
    
    show_footer
    read -n 1 key
}

# Function to handle disk operations submenu
disk_operations() {
    show_header
    echo -e "${WHITE}Disk Operations${RESET}"
    echo
    
    # Show disk operations submenu
    echo "1. Scan disks"
    echo "2. Mount filesystem"
    echo "3. Unmount filesystem"
    echo "4. Format partition"
    echo "5. Check filesystem"
    echo "6. Back to main menu"
    echo
    
    echo -n "Select an option: "
    read -n 1 disk_option
    echo
    
    case "$disk_option" in
        1) scan_disks ;;
        2) mount_filesystem ;;
        3) unmount_filesystem ;;
        4) format_partition ;;
        5) check_filesystem ;;
        *)
            # Back to main menu or invalid option
            ;;
    esac
}

# Function for advanced system tools
advanced_tools() {
    show_header
    echo -e "${WHITE}Advanced System Tools${RESET}"
    echo
    
    # Show advanced tools submenu
    echo "1. Hardware Information Tools"
    echo "2. System Monitoring"
    echo "3. Security Tools"
    echo "4. Boot Repair"
    echo "5. Back to main menu"
    echo
    
    echo -n "Select an option: "
    read -n 1 tool_option
    echo
    
    case "$tool_option" in
        1)
            show_header
            echo -e "${WHITE}Hardware Information Tools${RESET}"
            echo
            
            # Check if hardware tools are available
            if command -v lshw > /dev/null; then
                echo "1. Full Hardware Listing (lshw)"
                hw_tool_1=true
            else
                echo -e "${GRAY}1. Full Hardware Listing (lshw) - not available${RESET}"
                hw_tool_1=false
            fi
            
            if command -v dmidecode > /dev/null; then
                echo "2. System DMI Information (dmidecode)"
                hw_tool_2=true
            else
                echo -e "${GRAY}2. System DMI Information (dmidecode) - not available${RESET}"
                hw_tool_2=false
            fi
            
            if command -v lspci > /dev/null; then
                echo "3. PCI Devices (lspci)"
                hw_tool_3=true
            else
                echo -e "${GRAY}3. PCI Devices (lspci) - not available${RESET}"
                hw_tool_3=false
            fi
            
            if command -v lsusb > /dev/null; then
                echo "4. USB Devices (lsusb)"
                hw_tool_4=true
            else
                echo -e "${GRAY}4. USB Devices (lsusb) - not available${RESET}"
                hw_tool_4=false
            fi
            
            if command -v smartctl > /dev/null; then
                echo "5. Disk SMART Status (smartctl)"
                hw_tool_5=true
            else
                echo -e "${GRAY}5. Disk SMART Status (smartctl) - not available${RESET}"
                hw_tool_5=false
            fi
            
            echo "6. Back to advanced tools"
            echo
            
            echo -n "Select a tool: "
            read -n 1 hw_option
            echo
            
            case "$hw_option" in
                1)
                    if [ "$hw_tool_1" = true ]; then
                        log_message "Running lshw"
                        show_header
                        echo -e "${WHITE}Full Hardware Listing${RESET}"
                        echo
                        lshw
                        echo
                        show_footer
                        read -n 1 key
                    else
                        show_message "lshw is not available in this build" "error"
                    fi
                    ;;
                2)
                    if [ "$hw_tool_2" = true ]; then
                        log_message "Running dmidecode"
                        show_header
                        echo -e "${WHITE}System DMI Information${RESET}"
                        echo
                        dmidecode
                        echo
                        show_footer
                        read -n 1 key
                    else
                        show_message "dmidecode is not available in this build" "error"
                    fi
                    ;;
                3)
                    if [ "$hw_tool_3" = true ]; then
                        log_message "Running lspci"
                        show_header
                        echo -e "${WHITE}PCI Devices${RESET}"
                        echo
                        lspci -v
                        echo
                        show_footer
                        read -n 1 key
                    else
                        show_message "lspci is not available in this build" "error"
                    fi
                    ;;
                4)
                    if [ "$hw_tool_4" = true ]; then
                        log_message "Running lsusb"
                        show_header
                        echo -e "${WHITE}USB Devices${RESET}"
                        echo
                        lsusb -v
                        echo
                        show_footer
                        read -n 1 key
                    else
                        show_message "lsusb is not available in this build" "error"
                    fi
                    ;;
                5)
                    if [ "$hw_tool_5" = true ]; then
                        # Show disks and let user select one
                        show_header
                        echo -e "${WHITE}Disk SMART Status${RESET}"
                        echo
                        
                        # Show available disks
                        echo -e "${CYAN}Available Disks:${RESET}"
                        disks=$(lsblk -d -n -o NAME,SIZE,MODEL | grep -v loop | awk '{print $1}')
                        i=1
                        for disk in $disks; do
                            size=$(lsblk -d -n -o SIZE -b /dev/$disk)
                            model=$(lsblk -d -n -o MODEL /dev/$disk)
                            echo "$i. /dev/$disk ($model, $size bytes)"
                            i=$((i+1))
                        done
                        echo
                        
                        echo -n "Select disk to check: "
                        read disk_num
                        
                        # Validate input
                        if [[ "$disk_num" =~ ^[0-9]+$ ]] && [ "$disk_num" -ge 1 ] && [ "$disk_num" -le "$((i-1))" ]; then
                            disk=$(echo "$disks" | sed -n "${disk_num}p")
                            
                            log_message "Running smartctl on /dev/$disk"
                            show_header
                            echo -e "${WHITE}SMART Status for /dev/$disk${RESET}"
                            echo
                            
                            # Run smartctl
                            smartctl -a /dev/$disk
                            
                            echo
                            show_footer
                            read -n 1 key
                        else
                            show_message "Invalid disk selection" "error"
                        fi
                    else
                        show_message "smartctl is not available in this build" "error"
                    fi
                    ;;
                *)
                    # Back to advanced tools menu
                    ;;
            esac
            ;;
        2)
            show_header
            echo -e "${WHITE}System Monitoring${RESET}"
            echo
            
            # Check if monitoring tools are available
            if command -v htop > /dev/null; then
                echo "1. Process Monitor (htop)"
                mon_tool_1=true
            else
                echo -e "${GRAY}1. Process Monitor (htop) - not available${RESET}"
                mon_tool_1=false
            fi
            
            if command -v strace > /dev/null; then
                echo "2. System Call Tracer (strace)"
                mon_tool_2=true
            else
                echo -e "${GRAY}2. System Call Tracer (strace) - not available${RESET}"
                mon_tool_2=false
            fi
            
            echo "3. Memory Information"
            echo "4. CPU Information"
            echo "5. Back to advanced tools"
            echo
            
            echo -n "Select a tool: "
            read -n 1 mon_option
            echo
            
            case "$mon_option" in
                1)
                    if [ "$mon_tool_1" = true ]; then
                        log_message "Running htop"
                        htop
                    else
                        show_message "htop is not available in this build" "error"
                    fi
                    ;;
                2)
                    if [ "$mon_tool_2" = true ]; then
                        show_header
                        echo -e "${WHITE}System Call Tracer${RESET}"
                        echo
                        
                        echo -n "Enter process ID or command to trace: "
                        read trace_target
                        
                        if [ -z "$trace_target" ]; then
                            show_message "No target specified" "error"
                            return
                        fi
                        
                        log_message "Running strace on $trace_target"
                        
                        # Check if input is a PID or command
                        if [[ "$trace_target" =~ ^[0-9]+$ ]]; then
                            # It's a PID
                            strace -p "$trace_target"
                        else
                            # It's a command
                            strace "$trace_target"
                        fi
                        
                        echo
                        show_footer
                        read -n 1 key
                    else
                        show_message "strace is not available in this build" "error"
                    fi
                    ;;
                3)
                    show_header
                    echo -e "${WHITE}Memory Information${RESET}"
                    echo
                    
                    log_message "Showing memory information"
                    
                    echo -e "${CYAN}Memory Usage Summary:${RESET}"
                    free -h
                    echo
                    
                    echo -e "${CYAN}Memory Details:${RESET}"
                    cat /proc/meminfo
                    echo
                    
                    show_footer
                    read -n 1 key
                    ;;
                4)
                    show_header
                    echo -e "${WHITE}CPU Information${RESET}"
                    echo
                    
                    log_message "Showing CPU information"
                    
                    echo -e "${CYAN}CPU Model:${RESET}"
                    grep "model name" /proc/cpuinfo | head -1
                    echo
                    
                    echo -e "${CYAN}CPU Cores:${RESET}"
                    echo "Physical cores: $(grep -c "physical id" /proc/cpuinfo | sort -u)"
                    echo "Logical cores: $(grep -c processor /proc/cpuinfo)"
                    echo
                    
                    echo -e "${CYAN}CPU Detailed Information:${RESET}"
                    cat /proc/cpuinfo
                    echo
                    
                    show_footer
                    read -n 1 key
                    ;;
                *)
                    # Back to advanced tools menu
                    ;;
            esac
            ;;
        3)
            show_header
            echo -e "${WHITE}Security Tools${RESET}"
            echo
            
            # Check if security tools are available
            if command -v openssl > /dev/null; then
                echo "1. Generate Password Hash"
                sec_tool_1=true
            else
                echo -e "${GRAY}1. Generate Password Hash - not available${RESET}"
                sec_tool_1=false
            fi
            
            echo "2. Generate Random Password"
            
            if command -v openssl > /dev/null; then
                echo "3. Encrypt File"
                sec_tool_3=true
            else
                echo -e "${GRAY}3. Encrypt File - not available${RESET}"
                sec_tool_3=false
            fi
            
            if command -v openssl > /dev/null; then
                echo "4. Decrypt File"
                sec_tool_4=true
            else
                echo -e "${GRAY}4. Decrypt File - not available${RESET}"
                sec_tool_4=false
            fi
            
            echo "5. Back to advanced tools"
            echo
            
            echo -n "Select a tool: "
            read -n 1 sec_option
            echo
            
            case "$sec_option" in
                1)
                    if [ "$sec_tool_1" = true ]; then
                        show_header
                        echo -e "${WHITE}Generate Password Hash${RESET}"
                        echo
                        
                        echo -n "Enter password to hash: "
                        # Use -s flag to hide password input
                        read -s password
                        echo
                        
                        if [ -z "$password" ]; then
                            show_message "No password provided" "error"
                            return
                        fi
                        
                        log_message "Generating password hash"
                        
                        # Create hash using multiple algorithms
                        echo -e "${CYAN}MD5 (not secure, for compatibility only):${RESET}"
                        echo "$password" | openssl passwd -1 -stdin
                        echo
                        
                        echo -e "${CYAN}SHA-256:${RESET}"
                        echo "$password" | openssl passwd -5 -stdin
                        echo
                        
                        echo -e "${CYAN}SHA-512 (recommended):${RESET}"
                        echo "$password" | openssl passwd -6 -stdin
                        echo
                        
                        show_footer
                        read -n 1 key
                    else
                        show_message "openssl is not available in this build" "error"
                    fi
                    ;;
                2)
                    show_header
                    echo -e "${WHITE}Generate Random Password${RESET}"
                    echo
                    
                    echo -n "Enter desired password length: "
                    read length
                    
                    if ! [[ "$length" =~ ^[0-9]+$ ]] || [ "$length" -lt 1 ]; then
                        show_message "Invalid length" "error"
                        return
                    fi
                    
                    log_message "Generating random password of length $length"
                    
                    # Try multiple methods of generating random passwords
                    password=""
                    
                    if command -v openssl > /dev/null; then
                        password=$(openssl rand -base64 $((length*2)) | tr -dc 'a-zA-Z0-9!@#$%^&*()_+' | head -c "$length")
                    elif [ -f /dev/urandom ]; then
                        password=$(< /dev/urandom tr -dc 'a-zA-Z0-9!@#$%^&*()_+' | head -c "$length")
                    else
                        # Fallback method using built-in shell functions
                        chars="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()_+"
                        for i in $(seq 1 "$length"); do
                            password="$password${chars:$((RANDOM % ${#chars})):1}"
                        done
                    fi
                    
                    echo -e "${CYAN}Generated Password:${RESET}"
                    echo "$password"
                    echo
                    
                    show_footer
                    read -n 1 key
                    ;;
                3)
                    if [ "$sec_tool_3" = true ]; then
                        show_header
                        echo -e "${WHITE}Encrypt File${RESET}"
                        echo
                        
                        echo -n "Enter path to file to encrypt: "
                        read source_file
                        
                        if [ -z "$source_file" ] || [ ! -f "$source_file" ]; then
                            show_message "Invalid file path" "error"
                            return
                        fi
                        
                        echo -n "Enter path for encrypted output file: "
                        read dest_file
                        
                        if [ -z "$dest_file" ]; then
                            show_message "Invalid output path" "error"
                            return
                        fi
                        
                        log_message "Encrypting file: $source_file -> $dest_file"
                        
                        # Use OpenSSL for encryption
                        openssl enc -aes-256-cbc -md sha512 -pbkdf2 -iter 100000 -salt -in "$source_file" -out "$dest_file"
                        encrypt_status=$?
                        
                        if [ $encrypt_status -eq 0 ]; then
                            show_message "File encrypted successfully" "success"
                        else
                            show_message "Encryption failed" "error"
                        fi
                    else
                        show_message "openssl is not available in this build" "error"
                    fi
                    ;;
                4)
                    if [ "$sec_tool_4" = true ]; then
                        show_header
                        echo -e "${WHITE}Decrypt File${RESET}"
                        echo
                        
                        echo -n "Enter path to encrypted file: "
                        read source_file
                        
                        if [ -z "$source_file" ] || [ ! -f "$source_file" ]; then
                            show_message "Invalid file path" "error"
                            return
                        fi
                        
                        echo -n "Enter path for decrypted output file: "
                        read dest_file
                        
                        if [ -z "$dest_file" ]; then
                            show_message "Invalid output path" "error"
                            return
                        fi
                        
                        log_message "Decrypting file: $source_file -> $dest_file"
                        
                        # Use OpenSSL for decryption
                        openssl enc -d -aes-256-cbc -md sha512 -pbkdf2 -iter 100000 -in "$source_file" -out "$dest_file"
                        decrypt_status=$?
                        
                        if [ $decrypt_status -eq 0 ]; then
                            show_message "File decrypted successfully" "success"
                        else
                            show_message "Decryption failed" "error"
                        fi
                    else
                        show_message "openssl is not available in this build" "error"
                    fi
                    ;;
                *)
                    # Back to advanced tools menu
                    ;;
            esac
            ;;
        4)
            show_header
            echo -e "${WHITE}Boot Repair${RESET}"
            echo
            
            # Check if boot repair tools are available
            if command -v grub-install > /dev/null; then
                echo "1. Install GRUB Bootloader"
                boot_tool_1=true
            else
                echo -e "${GRAY}1. Install GRUB Bootloader - not available${RESET}"
                boot_tool_1=false
            fi
            
            if command -v efibootmgr > /dev/null; then
                echo "2. Manage EFI Boot Entries"
                boot_tool_2=true
            else
                echo -e "${GRAY}2. Manage EFI Boot Entries - not available${RESET}"
                boot_tool_2=false
            fi
            
            echo "3. Back to advanced tools"
            echo
            
            echo -n "Select a tool: "
            read -n 1 boot_option
            echo
            
            case "$boot_option" in
                1)
                    if [ "$boot_tool_1" = true ]; then
                        show_header
                        echo -e "${WHITE}Install GRUB Bootloader${RESET}"
                        echo
                        
                        # Show available disks
                        echo -e "${CYAN}Available Disks:${RESET}"
                        lsblk -d -o NAME,SIZE,MODEL | grep -v loop
                        echo
                        
                        echo -n "Enter target disk (e.g., sda): "
                        read target_disk
                        
                        if [ -z "$target_disk" ] || [ ! -b "/dev/$target_disk" ]; then
                            show_message "Invalid disk" "error"
                            return
                        fi
                        
                        # Choose between BIOS and UEFI mode
                        echo
                        echo -e "${CYAN}GRUB Install Mode:${RESET}"
                        echo "1. BIOS mode (Legacy)"
                        echo "2. UEFI mode"
                        echo
                        
                        echo -n "Select mode: "
                        read -n 1 grub_mode
                        echo
                        
                        # Need to ask for mount point for UEFI mode
                        if [ "$grub_mode" = "2" ]; then
                            # Show mounted filesystems
                            echo
                            echo -e "${CYAN}Mounted EFI Partitions:${RESET}"
                            mount | grep -i "efi"
                            echo
                            
                            echo -n "Enter EFI partition mount point (e.g., /mnt/sda1): "
                            read efi_mount
                            
                            if [ -z "$efi_mount" ] || [ ! -d "$efi_mount" ]; then
                                show_message "Invalid mount point" "error"
                                return
                            fi
                        fi
                        
                        log_message "Installing GRUB on /dev/$target_disk"
                        
                        # Install GRUB
                        if [ "$grub_mode" = "1" ]; then
                            # BIOS mode
                            grub-install --target=i386-pc "/dev/$target_disk"
                            grub_status=$?
                        else
                            # UEFI mode
                            grub-install --target=x86_64-efi --efi-directory="$efi_mount" --bootloader-id=GRUB
                            grub_status=$?
                        fi
                        
                        if [ $grub_status -eq 0 ]; then
                            # Update GRUB
                            echo "Updating GRUB configuration..."
                            grub-mkconfig -o /boot/grub/grub.cfg
                            config_status=$?
                            
                            if [ $config_status -eq 0 ]; then
                                show_message "GRUB installed and configured successfully" "success"
                            else
                                show_message "GRUB installed but configuration failed" "warning"
                            fi
                        else
                            show_message "GRUB installation failed" "error"
                        fi
                    else
                        show_message "GRUB installation tools are not available in this build" "error"
                    fi
                    ;;
                2)
                    if [ "$boot_tool_2" = true ]; then
                        show_header
                        echo -e "${WHITE}Manage EFI Boot Entries${RESET}"
                        echo
                        
                        # Show EFI boot submenu
                        echo "1. List boot entries"
                        echo "2. Create new boot entry"
                        echo "3. Delete boot entry"
                        echo "4. Set next boot option"
                        echo "5. Back to boot repair"
                        echo
                        
                        echo -n "Select option: "
                        read -n 1 efi_option
                        echo
                        
                        case "$efi_option" in
                            1)
                                show_header
                                echo -e "${WHITE}EFI Boot Entries${RESET}"
                                echo
                                
                                log_message "Listing EFI boot entries"
                                efibootmgr -v
                                
                                echo
                                show_footer
                                read -n 1 key
                                ;;
                            2)
                                show_header
                                echo -e "${WHITE}Create EFI Boot Entry${RESET}"
                                echo
                                
                                # Show available disks
                                echo -e "${CYAN}Available Disks:${RESET}"
                                lsblk -d -o NAME,SIZE,MODEL | grep -v loop
                                echo
                                
                                echo -n "Enter disk (e.g., sda): "
                                read efi_disk
                                
                                if [ -z "$efi_disk" ] || [ ! -b "/dev/$efi_disk" ]; then
                                    show_message "Invalid disk" "error"
                                    return
                                fi
                                
                                echo -n "Enter partition number (e.g., 1): "
                                read efi_part
                                
                                if ! [[ "$efi_part" =~ ^[0-9]+$ ]]; then
                                    show_message "Invalid partition number" "error"
                                    return
                                fi
                                
                                echo -n "Enter label for boot entry: "
                                read efi_label
                                
                                if [ -z "$efi_label" ]; then
                                    show_message "Invalid label" "error"
                                    return
                                fi
                                
                                echo -n "Enter EFI binary path (e.g., /EFI/Boot/bootx64.efi): "
                                read efi_path
                                
                                if [ -z "$efi_path" ]; then
                                    show_message "Invalid path" "error"
                                    return
                                fi
                                
                                log_message "Creating EFI boot entry: $efi_label on /dev/$efi_disk part $efi_part for $efi_path"
                                
                                # Create EFI boot entry
                                efibootmgr --create --disk "/dev/$efi_disk" --part $efi_part --label "$efi_label" --loader "$efi_path"
                                efi_status=$?
                                
                                if [ $efi_status -eq 0 ]; then
                                    show_message "EFI boot entry created successfully" "success"
                                else
                                    show_message "Failed to create EFI boot entry" "error"
                                fi
                                ;;
                            3)
                                show_header
                                echo -e "${WHITE}Delete EFI Boot Entry${RESET}"
                                echo
                                
                                # Show current boot entries
                                echo -e "${CYAN}Current Boot Entries:${RESET}"
                                efibootmgr
                                echo
                                
                                echo -n "Enter boot number to delete (e.g., 0001): "
                                read boot_num
                                
                                if [ -z "$boot_num" ]; then
                                    show_message "Invalid boot number" "error"
                                    return
                                fi
                                
                                # Confirm deletion
                                echo -e "${RED}WARNING: This will delete boot entry $boot_num.${RESET}"
                                echo -n "Are you sure? (y/n): "
                                read -n 1 confirm
                                echo
                                
                                if [ "$confirm" != "y" ] && [ "$confirm" != "Y" ]; then
                                    show_message "Operation cancelled" "info"
                                    return
                                fi
                                
                                log_message "Deleting EFI boot entry: $boot_num"
                                
                                # Delete boot entry
                                efibootmgr --bootnum $boot_num --delete-bootnum
                                del_status=$?
                                
                                if [ $del_status -eq 0 ]; then
                                    show_message "Boot entry deleted successfully" "success"
                                else
                                    show_message "Failed to delete boot entry" "error"
                                fi
                                ;;
                            4)
                                show_header
                                echo -e "${WHITE}Set Next Boot Option${RESET}"
                                echo
                                
                                # Show current boot entries
                                echo -e "${CYAN}Current Boot Entries:${RESET}"
                                efibootmgr
                                echo
                                
                                echo -n "Enter boot number for next boot (e.g., 0001): "
                                read boot_num
                                
                                if [ -z "$boot_num" ]; then
                                    show_message "Invalid boot number" "error"
                                    return
                                fi
                                
                                log_message "Setting next boot to entry: $boot_num"
                                
                                # Set next boot
                                efibootmgr --bootnum $boot_num --bootnext
                                next_status=$?
                                
                                if [ $next_status -eq 0 ]; then
                                    show_message "Next boot option set successfully" "success"
                                else
                                    show_message "Failed to set next boot option" "error"
                                fi
                                ;;
                            *)
                                # Back to boot repair menu
                                ;;
                        esac
                    else
                        show_message "efibootmgr is not available in this build" "error"
                    fi
                    ;;
                *)
                    # Back to advanced tools menu
                    ;;
            esac
            ;;
        *)
            # Back to main menu
            ;;
    esac
}

# Function to show the main menu and handle user input
main_menu() {
    while true; do
        show_header
        echo -e "${WHITE}Main Menu${RESET}"
        echo
        echo "1. System Information"
        echo "2. Disk Operations"
        echo "3. Network Operations"
        echo "4. Data Recovery"
        echo "5. ZFS Operations"
        echo "6. Advanced System Tools"
        echo "7. View Logs"
        echo "8. Shell"
        echo "9. Help"
        echo "0. Reboot/Shutdown"
        echo
        
        echo -n "Select an option: "
        read -n 1 option
        echo
        
        case "$option" in
            1) show_system_info ;;
            2) disk_operations ;;
            3) network_operations ;;
            4) data_recovery ;;
            5) zfs_operations ;;
            6) advanced_tools ;;
            7) show_logs ;;
            8)
                echo "Launching shell. Type 'exit' to return to OneRecovery."
                /bin/ash
                ;;
            9) show_help ;;
            0)
                show_header
                echo -e "${WHITE}Reboot/Shutdown${RESET}"
                echo
                echo "1. Reboot system"
                echo "2. Shutdown system"
                echo "3. Back to main menu"
                echo
                
                echo -n "Select an option: "
                read -n 1 power_option
                echo
                
                case "$power_option" in
                    1)
                        log_message "User initiated reboot"
                        show_message "System will reboot now..." "warning"
                        reboot
                        ;;
                    2)
                        log_message "User initiated shutdown"
                        show_message "System will shut down now..." "warning"
                        poweroff
                        ;;
                    *)
                        # Back to main menu
                        ;;
                esac
                ;;
            q|Q) 
                log_message "Exiting OneRecovery TUI"
                clear
                exit 0
                ;;
            h|H) show_help ;;
            *) show_message "Invalid option" "error" ;;
        esac
    done
}

# Initialize
log_message "Starting OneRecovery TUI v$VERSION"
detect_system_info
main_menu